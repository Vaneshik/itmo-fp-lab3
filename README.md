# Лабораторная работа №3

---

Выполнил: Чусовлянов Максим Сергеевич

Группа: P3307

Преподаватель: Пенской Александр Владимирович

---

## Требования

- обязательно должна быть реализована линейная интерполяция (отрезками, [link](https://en.wikipedia.org/wiki/Linear_interpolation));

- настройки алгоритма интерполяции и выводимых данных должны задаваться через аргументы командной строки:

    - какие алгоритмы использовать (в том числе два сразу);

    - частота дискретизации результирующих данных;

    - и т.п.;

- входные данные должны задаваться в текстовом формате на подобии ".csv" (к примеру `x;y\n` или `x\ty\n`) и подаваться на стандартный ввод, входные данные должны быть отсортированы по возрастанию x;

- выходные данные должны подаваться на стандартный вывод;

- программа должна работать в потоковом режиме (пример -- `cat | grep 11`), это значит, что при запуске программы она должна ожидать получения данных на стандартный ввод, и, по мере получения достаточного количества данных, должна выводить рассчитанные точки в стандартный вывод;

## Реализация

### Общая схема работы

Для реализации потоковой обработки данных использован модуль `core.async` из Clojure. Данный подход обеспечивает эффективную асинхронную обработку потока входных данных.

Программа построена на основе каналов (`chan`) и легковесных процессов через макрос `go`. Схема работы:

- входной поток преобразуется в канал с сырыми данными;

- go-процесс валидации проверяет монотонность x-координат входящих точек;

- проверенные точки поступают в единый входной канал для всех алгоритмов;

- используя `mult`, входной канал размножается и направляется в несколько параллельных процессоров интерполяции;

- все процессоры записывают результаты в общий выходной канал;

- отдельный go-процесс читает из выходного канала и выводит результаты в консоль.

### Алгоритмы интерполяции

Реализовано два алгоритма интерполяции:

- Линейная
- Лагранжа

Для реализации алгоритмов использованы мультиметоды, что позволяет легко расширять функциональность. Вместо обычных функций с case, каждый алгоритм определяется через свой метод:

```clojure
(defmulti window-size (fn [algo _] algo))
(defmethod window-size "linear" [_ _] 2)
(defmethod window-size "lagrange" [_ window-param] window-param)
```

Аналогично для создания самой функции интерполяции через `create-interpolator`. Такой подход упрощает добавление новых методов интерполяции.

### Особенности реализации

Основная сложность - реализация механики динамического окна с корректной обработкой граничных случаев.

Функция `slide-window` добавляет новую точку в окно фиксированного размера, при переполнении вытесняя самую старую. 

Обработка окна разделена на три фазы, каждая в отдельной функции:

- `handle-filling` - первое заполнение окна, вычисляет точки от начала до середины интервала
- `handle-sliding` - обрабатывает одну точку в центре при сдвиге окна
- `handle-finalization` - завершающая обработка хвоста данных

Обработка ошибок реализована через стандартный try-catch с перенаправлением сообщений через `binding`. Вывод результатов выполняется через `doseq` для итерации по рассчитанным точкам.

## Тестирование

Для проверки правильности работы отдельных функций написаны [unit-тесты](test/itmo_fp_lab3/test.clj).

Также, ниже приведены примеры запуска программы на потоках точек из [файлов](data):

### Один алгоритм

Команда:

```bash
cat data/data.csv | lein run -s 0.3 -a linear
```

Вывод:

```bash
linear: -0,90 0,03
linear: -0,60 0,13
linear: -0,30 0,22
linear: 0,00 0,86
linear: 0,30 0,67
linear: 0,60 0,48
linear: 0,90 0,29
linear: 1,20 0,10
linear: 1,50 -0,09
linear: 1,80 -0,39
linear: 2,10 -0,49
linear: 2,40 -0,58
linear: 2,70 -0,68
linear: 3,00 -0,77
linear: 3,30 -1,39
linear: 3,60 -1,11
linear: 3,90 -0,82
linear: 4,20 -0,53
linear: 4,50 -0,25
linear: 4,80 0,65
linear: 5,10 0,56
linear: 5,40 0,46
linear: 5,70 0,37
linear: 6,00 0,27
linear: 6,30 -0,18
linear: 6,60 -0,08
linear: 6,90 0,01
linear: 7,20 0,11
linear: 7,50 0,21
linear: 7,80 0,30
linear: 8,10 0,40
linear: 8,40 0,49
linear: 8,70 0,59
linear: 9,00 0,68
linear: 9,30 0,78
linear: 9,60 1,25
linear: 9,90 1,06
linear: 10,20 0,87
linear: 10,50 0,68
linear: 10,80 0,49
linear: 11,10 0,30
linear: 11,40 0,11
linear: 11,70 -0,08
linear: 12,00 -0,27
linear: 12,30 -0,47
linear: 12,60 -0,66
linear: 12,90 -0,85
```

Данные:

```csv
-1.000;0.00
0.571;0.50
2.142;-0.50
3.712;-1.00
5.283;0.50
6.854;0.00
8.425;0.50
9.996;1.00
11.568;0.00
13.139;-1.00
```

### Два алгоритма

Команда:

```bash
cat data/data.txt | lein run -s 0.5 -a linear,lagrange -w 3
```

Вывод:

```bash
linear: 1,50 1,16
linear: 2,00 1,36
linear: 2,50 1,56
linear: 3,00 2,36
linear: 3,50 2,05
linear: 4,00 1,73
linear: 4,50 1,41
linear: 5,00 1,09
linear: 5,50 0,77
linear: 6,00 0,45
linear: 6,50 -0,20
linear: 7,00 0,27
linear: 7,50 0,75
lagrange: 1,50 1,37
lagrange: 2,00 1,72
lagrange: 2,50 1,95
lagrange: 3,00 2,05
linear: 8,00 1,44
linear: 8,50 1,54
linear: 9,00 1,64
linear: 9,50 1,74
linear: 10,00 2,54
linear: 10,50 2,23
linear: 11,00 1,91
linear: 11,50 1,59
lagrange: 3,50 2,05
lagrange: 4,00 1,73
lagrange: 4,50 1,41
linear: 12,00 0,83
lagrange: 5,00 1,09
linear: 12,50 1,03
linear: 13,00 1,22
linear: 13,50 1,42
lagrange: 5,50 0,55
lagrange: 6,00 0,14
lagrange: 6,50 -0,01
linear: 14,00 1,68
linear: 14,50 1,84
linear: 15,00 2,00
linear: 15,50 2,16
linear: 16,00 2,32
lagrange: 7,00 0,34
lagrange: 7,50 0,87
linear: 16,50 2,52
lagrange: 8,00 1,30
linear: 17,00 2,36
lagrange: 8,50 1,64
linear: 17,50 2,20
lagrange: 9,00 1,88
lagrange: 9,50 2,07
lagrange: 10,00 2,13
lagrange: 10,50 2,09
linear: 18,00 2,04
lagrange: 11,00 1,86
lagrange: 11,50 1,44
lagrange: 12,00 1,15
lagrange: 12,50 0,98
lagrange: 13,00 0,94
lagrange: 13,50 1,45
lagrange: 14,00 1,64
lagrange: 14,50 1,82
lagrange: 15,00 2,00
lagrange: 15,50 2,27
lagrange: 16,00 2,43
lagrange: 16,50 2,50
lagrange: 17,00 2,46
lagrange: 17,50 2,32
lagrange: 18,00 2,08
```

Данные:

```text
1.111;              1.00
3.571;              2.00
5.142;              1.00
6.712;              0.00
8.283;              1.50
10.854;             2.00
12.425;             1.00
14.996;             2.00
16.568;             2.50
18.139;             2.00
```


## Вывод

В ходе выполнения работы я разработал программу для потоковой интерполяции данных на Clojure. Использование модуля `core.async` позволило организовать обработку данных через каналы и go-блоки без блокировки основного потока. Применение мультиметодов для реализации различных алгоритмов интерполяции обеспечило гибкость и возможность легкого добавления новых методов. Довольно интересной задачей была реализация механики скользящего окна с корректной обработкой граничных случаев — начального заполнения, процесса работы и финализации. В целом работа показала преимущества функционального подхода для решения задач потоковой обработки данных.
